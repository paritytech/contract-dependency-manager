import { execSync } from "child_process";
import { existsSync, readFileSync } from "fs";
import { resolve } from "path";

export interface ContractInfo {
    /** Crate name (e.g., "reputation") */
    name: string;
    /** CDM package name (e.g., "@polkadot/reputation") - null if no CDM macro or not yet built */
    cdmPackage: string | null;
    /** Description from Cargo.toml [package] section */
    description: string | null;
    /** Authors from Cargo.toml [package] section */
    authors: string[];
    /** Homepage URL from Cargo.toml [package] section */
    homepage: string | null;
    /** Repository URL from Cargo.toml [package] section */
    repository: string | null;
    /** Absolute path to readme file */
    readmePath: string | null;
    /** Path to contract crate directory */
    path: string;
    /** Crate names this contract depends on (from Cargo dependency graph) */
    dependsOnCrates: string[];
}

export interface DeploymentOrder {
    /** Crate names in deployment order */
    crateNames: string[];
    /** CDM package names in deployment order (null for contracts without CDM) */
    cdmPackages: (string | null)[];
    /** Full contract info for each contract, in deployment order */
    contracts: ContractInfo[];
}

export interface DeploymentOrderLayered {
    /** Layers of crate names - each layer can be processed in parallel */
    layers: string[][];
    /** Full contract info indexed by crate name */
    contractMap: Map<string, ContractInfo>;
    /** CDM package name indexed by crate name (only contracts with CDM packages) */
    cdmPackageMap: Map<string, string>;
}

// --- Cargo metadata types ---

interface CargoMetadata {
    packages: CargoPackage[];
    workspace_members: string[];
    resolve: { nodes: ResolveNode[] } | null;
}

interface CargoPackage {
    name: string;
    id: string;
    description: string | null;
    authors: string[];
    homepage: string | null;
    repository: string | null;
    readme: string | null;
    manifest_path: string;
    dependencies: CargoDependency[];
}

interface CargoDependency {
    name: string;
    kind: string | null;
    path: string | null;
}

interface ResolveNode {
    id: string;
    deps: { name: string; pkg: string }[];
}

/**
 * Get workspace metadata from Cargo's resolver.
 * This is 100% reliable - it uses Cargo's own dependency resolution.
 */
function getCargoMetadata(rootDir: string): CargoMetadata {
    const manifestPath = resolve(rootDir, "Cargo.toml");
    const output = execSync(
        `cargo metadata --format-version 1 --manifest-path "${manifestPath}" --no-deps`,
        { cwd: rootDir, encoding: "utf-8", stdio: ["pipe", "pipe", "pipe"] },
    );
    return JSON.parse(output);
}

/**
 * Check if a package is a PVM contract by checking its dependencies.
 * A PVM contract has pvm_contract as a normal (non-dev, non-build) dependency.
 */
function isPvmContract(pkg: CargoPackage): boolean {
    return pkg.dependencies.some(
        (d) =>
            d.name === "pvm_contract" &&
            (d.kind === null || d.kind === "normal"),
    );
}

/**
 * Read CDM package name from post-build .cdm.json file.
 * Returns null if contract has no CDM annotation or hasn't been built yet.
 *
 * The .cdm.json file is generated by cargo-pvm-contract during compilation
 * by extracting the __PVM_CDM symbol from the compiled ELF.
 */
export function readCdmPackage(rootDir: string, crateName: string): string | null {
    const cdmPath = resolve(rootDir, `target/${crateName}.release.cdm.json`);
    if (!existsSync(cdmPath)) return null;
    try {
        const data = JSON.parse(readFileSync(cdmPath, "utf-8"));
        return data.cdmPackage ?? null;
    } catch {
        return null;
    }
}

/**
 * Detect all PVM contracts in a workspace using cargo metadata.
 *
 * This replaces the old regex-based detection with Cargo's own resolver:
 * - Workspace members come from cargo metadata (not recursive file scanning)
 * - PVM contract detection uses resolved dependency graph (not string matching)
 * - Inter-contract dependencies come from Cargo.toml (not regex on source)
 * - CDM package names come from .cdm.json files (not regex on source)
 */
export function detectContracts(rootDir: string): ContractInfo[] {
    const meta = getCargoMetadata(rootDir);
    const workspacePkgIds = new Set(meta.workspace_members);

    // Filter to workspace members that are PVM contracts
    const pvmPackages = meta.packages.filter(
        (pkg) => workspacePkgIds.has(pkg.id) && isPvmContract(pkg),
    );

    // Build set of known contract crate names for filtering deps
    const contractNames = new Set(pvmPackages.map((p) => p.name));

    return pvmPackages.map((pkg) => {
        // Get inter-contract dependencies from Cargo's dependency list
        // Only include normal dependencies that are also PVM contracts in this workspace
        const deps = pkg.dependencies
            .filter(
                (d) =>
                    (d.kind === null || d.kind === "normal") &&
                    contractNames.has(d.name),
            )
            .map((d) => d.name);

        const manifestDir = resolve(pkg.manifest_path, "..");

        return {
            name: pkg.name,
            cdmPackage: readCdmPackage(rootDir, pkg.name),
            description: pkg.description,
            authors: pkg.authors,
            homepage: pkg.homepage,
            repository: pkg.repository,
            readmePath: pkg.readme
                ? resolve(manifestDir, pkg.readme)
                : findReadme(manifestDir),
            path: manifestDir,
            dependsOnCrates: deps,
        };
    });
}

/**
 * Build a dependency graph from contract info.
 */
export function buildDependencyGraph(
    contracts: ContractInfo[],
): Map<string, string[]> {
    const graph = new Map<string, string[]>();
    const knownCrates = new Set<string>(contracts.map((c) => c.name));

    for (const contract of contracts) {
        const validDeps = contract.dependsOnCrates.filter((dep) =>
            knownCrates.has(dep),
        );
        graph.set(contract.name, validDeps);
    }

    return graph;
}

/**
 * Topological sort using Kahn's algorithm.
 * Returns nodes in dependency order (dependencies come first).
 */
export function toposort(graph: Map<string, string[]>): string[] {
    const inDegree = new Map<string, number>();
    const dependents = new Map<string, string[]>();

    for (const [node, deps] of graph) {
        if (!inDegree.has(node)) {
            inDegree.set(node, 0);
        }
        if (!dependents.has(node)) {
            dependents.set(node, []);
        }

        for (const dep of deps) {
            if (!inDegree.has(dep)) {
                inDegree.set(dep, 0);
            }
            if (!dependents.has(dep)) {
                dependents.set(dep, []);
            }
        }
    }

    for (const [node, deps] of graph) {
        inDegree.set(node, deps.length);
        for (const dep of deps) {
            dependents.get(dep)!.push(node);
        }
    }

    const queue: string[] = [];
    for (const [node, degree] of inDegree) {
        if (degree === 0) {
            queue.push(node);
        }
    }
    queue.sort();

    const result: string[] = [];

    while (queue.length > 0) {
        queue.sort();
        const node = queue.shift()!;
        result.push(node);

        for (const dependent of dependents.get(node) || []) {
            const newDegree = inDegree.get(dependent)! - 1;
            inDegree.set(dependent, newDegree);
            if (newDegree === 0) {
                queue.push(dependent);
            }
        }
    }

    if (result.length !== inDegree.size) {
        const remaining = [...inDegree.entries()]
            .filter(([_, degree]) => degree > 0)
            .map(([node]) => node);
        throw new Error(
            `Circular dependency detected involving: ${remaining.join(", ")}`,
        );
    }

    return result;
}

/**
 * Topological sort (layered) using modified Kahn's algorithm.
 * Collects ALL zero-in-degree nodes at each iteration as a layer.
 * Each layer can be processed in parallel.
 */
export function toposortLayers(graph: Map<string, string[]>): string[][] {
    const inDegree = new Map<string, number>();
    const dependents = new Map<string, string[]>();

    for (const [node, deps] of graph) {
        if (!inDegree.has(node)) inDegree.set(node, 0);
        if (!dependents.has(node)) dependents.set(node, []);
        for (const dep of deps) {
            if (!inDegree.has(dep)) inDegree.set(dep, 0);
            if (!dependents.has(dep)) dependents.set(dep, []);
        }
    }

    for (const [node, deps] of graph) {
        inDegree.set(node, deps.length);
        for (const dep of deps) {
            dependents.get(dep)!.push(node);
        }
    }

    let queue: string[] = [];
    for (const [node, degree] of inDegree) {
        if (degree === 0) queue.push(node);
    }

    const layers: string[][] = [];
    let processed = 0;

    while (queue.length > 0) {
        queue.sort();
        layers.push([...queue]);
        processed += queue.length;

        const nextQueue: string[] = [];
        for (const node of queue) {
            for (const dependent of dependents.get(node) || []) {
                const newDegree = inDegree.get(dependent)! - 1;
                inDegree.set(dependent, newDegree);
                if (newDegree === 0) {
                    nextQueue.push(dependent);
                }
            }
        }
        queue = nextQueue;
    }

    if (processed !== inDegree.size) {
        const remaining = [...inDegree.entries()]
            .filter(([_, d]) => d > 0)
            .map(([n]) => n);
        throw new Error(
            `Circular dependency detected involving: ${remaining.join(", ")}`,
        );
    }

    return layers;
}

/**
 * Create a mapping from crate name to CDM package name.
 */
export function createCrateToPackageMap(
    contracts: ContractInfo[],
): Map<string, string> {
    const map = new Map<string, string>();
    for (const contract of contracts) {
        if (contract.cdmPackage) {
            map.set(contract.name, contract.cdmPackage);
        }
    }
    return map;
}

/**
 * Detect contracts and determine deployment order based on dependencies.
 * Uses cargo metadata for reliable workspace and dependency resolution.
 */
export function detectDeploymentOrder(rootDir: string): DeploymentOrder {
    const contracts = detectContracts(rootDir);
    const graph = buildDependencyGraph(contracts);
    const sortedCrates = toposort(graph);

    const crateToPackage = createCrateToPackageMap(contracts);
    const sortedPackages = sortedCrates.map(
        (crate) => crateToPackage.get(crate) || null,
    );

    const crateToContract = new Map(contracts.map((c) => [c.name, c]));
    const sortedContracts = sortedCrates.map(
        (crate) => crateToContract.get(crate)!,
    );

    return {
        crateNames: sortedCrates,
        cdmPackages: sortedPackages,
        contracts: sortedContracts,
    };
}

/**
 * Detect contracts and determine layered deployment order.
 * Each layer contains contracts that can be deployed in parallel.
 */
export function detectDeploymentOrderLayered(rootDir: string): DeploymentOrderLayered {
    const contracts = detectContracts(rootDir);
    const graph = buildDependencyGraph(contracts);
    const layers = toposortLayers(graph);

    const cdmPackageMap = new Map<string, string>();
    const contractMap = new Map<string, ContractInfo>();

    for (const contract of contracts) {
        contractMap.set(contract.name, contract);
        if (contract.cdmPackage) {
            cdmPackageMap.set(contract.name, contract.cdmPackage);
        }
    }

    return { layers, contractMap, cdmPackageMap };
}

function findReadme(dir: string): string | null {
    for (const name of ["README.md", "README.txt", "README", "readme.md"]) {
        const p = resolve(dir, name);
        if (existsSync(p)) return p;
    }
    return null;
}

export function getGitRemoteUrl(rootDir: string): string | null {
    try {
        let url = execSync("git remote get-url origin", {
            cwd: rootDir,
            encoding: "utf-8",
            stdio: ["pipe", "pipe", "pipe"],
        }).trim();
        // Convert SSH to HTTPS
        if (url.startsWith("git@")) {
            url = url.replace(/^git@([^:]+):/, "https://$1/");
        }
        // Strip .git suffix
        url = url.replace(/\.git$/, "");
        return url;
    } catch {
        return null;
    }
}

export function readReadmeContent(readmePath: string | null): string {
    if (!readmePath || !existsSync(readmePath)) return "";
    try {
        const content = readFileSync(readmePath, "utf-8");
        const MAX_SIZE = 512 * 1024;
        if (content.length > MAX_SIZE) {
            console.warn(`Warning: README truncated to 512KB (was ${content.length} bytes)`);
            return content.slice(0, MAX_SIZE);
        }
        return content;
    } catch {
        return "";
    }
}
