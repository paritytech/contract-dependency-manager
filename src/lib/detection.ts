import { execSync } from "child_process";
import { existsSync, readFileSync } from "fs";
import { resolve } from "path";

export interface ContractInfo {
    /** Crate name (e.g., "reputation") */
    name: string;
    /** CDM package name (e.g., "@polkadot/reputation") - null if no CDM macro or not yet built */
    cdmPackage: string | null;
    /** Description from Cargo.toml [package] section */
    description: string | null;
    /** Path to contract crate directory */
    path: string;
    /** Crate names this contract depends on (from Cargo dependency graph) */
    dependsOnCrates: string[];
}

export interface DeploymentOrder {
    /** Crate names in deployment order */
    crateNames: string[];
    /** CDM package names in deployment order (null for contracts without CDM) */
    cdmPackages: (string | null)[];
    /** Full contract info for each contract, in deployment order */
    contracts: ContractInfo[];
}

// --- Cargo metadata types ---

interface CargoMetadata {
    packages: CargoPackage[];
    workspace_members: string[];
    resolve: { nodes: ResolveNode[] } | null;
}

interface CargoPackage {
    name: string;
    id: string;
    description: string | null;
    manifest_path: string;
    dependencies: CargoDependency[];
}

interface CargoDependency {
    name: string;
    kind: string | null;
    path: string | null;
}

interface ResolveNode {
    id: string;
    deps: { name: string; pkg: string }[];
}

/**
 * Get workspace metadata from Cargo's resolver.
 * This is 100% reliable - it uses Cargo's own dependency resolution.
 */
function getCargoMetadata(rootDir: string): CargoMetadata {
    const manifestPath = resolve(rootDir, "Cargo.toml");
    const output = execSync(
        `cargo metadata --format-version 1 --manifest-path "${manifestPath}" --no-deps`,
        { cwd: rootDir, encoding: "utf-8", stdio: ["pipe", "pipe", "pipe"] },
    );
    return JSON.parse(output);
}

/**
 * Check if a package is a PVM contract by checking its dependencies.
 * A PVM contract has pvm_contract as a normal (non-dev, non-build) dependency.
 */
function isPvmContract(pkg: CargoPackage): boolean {
    return pkg.dependencies.some(
        (d) =>
            d.name === "pvm_contract" &&
            (d.kind === null || d.kind === "normal"),
    );
}

/**
 * Read CDM package name from post-build .cdm.json file.
 * Returns null if contract has no CDM annotation or hasn't been built yet.
 *
 * The .cdm.json file is generated by cargo-pvm-contract during compilation
 * by extracting the __PVM_CDM symbol from the compiled ELF.
 */
function readCdmPackage(rootDir: string, crateName: string): string | null {
    const cdmPath = resolve(rootDir, `target/${crateName}.release.cdm.json`);
    if (!existsSync(cdmPath)) return null;
    try {
        const data = JSON.parse(readFileSync(cdmPath, "utf-8"));
        return data.cdmPackage ?? null;
    } catch {
        return null;
    }
}

/**
 * Detect all PVM contracts in a workspace using cargo metadata.
 *
 * This replaces the old regex-based detection with Cargo's own resolver:
 * - Workspace members come from cargo metadata (not recursive file scanning)
 * - PVM contract detection uses resolved dependency graph (not string matching)
 * - Inter-contract dependencies come from Cargo.toml (not regex on source)
 * - CDM package names come from .cdm.json files (not regex on source)
 */
export function detectContracts(rootDir: string): ContractInfo[] {
    const meta = getCargoMetadata(rootDir);
    const workspacePkgIds = new Set(meta.workspace_members);

    // Filter to workspace members that are PVM contracts
    const pvmPackages = meta.packages.filter(
        (pkg) => workspacePkgIds.has(pkg.id) && isPvmContract(pkg),
    );

    // Build set of known contract crate names for filtering deps
    const contractNames = new Set(pvmPackages.map((p) => p.name));

    return pvmPackages.map((pkg) => {
        // Get inter-contract dependencies from Cargo's dependency list
        // Only include normal dependencies that are also PVM contracts in this workspace
        const deps = pkg.dependencies
            .filter(
                (d) =>
                    (d.kind === null || d.kind === "normal") &&
                    contractNames.has(d.name),
            )
            .map((d) => d.name);

        const manifestDir = resolve(pkg.manifest_path, "..");

        return {
            name: pkg.name,
            cdmPackage: readCdmPackage(rootDir, pkg.name),
            description: pkg.description,
            path: manifestDir,
            dependsOnCrates: deps,
        };
    });
}

/**
 * Build a dependency graph from contract info.
 */
export function buildDependencyGraph(
    contracts: ContractInfo[],
): Map<string, string[]> {
    const graph = new Map<string, string[]>();
    const knownCrates = new Set<string>(contracts.map((c) => c.name));

    for (const contract of contracts) {
        const validDeps = contract.dependsOnCrates.filter((dep) =>
            knownCrates.has(dep),
        );
        graph.set(contract.name, validDeps);
    }

    return graph;
}

/**
 * Topological sort using Kahn's algorithm.
 * Returns nodes in dependency order (dependencies come first).
 */
export function toposort(graph: Map<string, string[]>): string[] {
    const inDegree = new Map<string, number>();
    const dependents = new Map<string, string[]>();

    for (const [node, deps] of graph) {
        if (!inDegree.has(node)) {
            inDegree.set(node, 0);
        }
        if (!dependents.has(node)) {
            dependents.set(node, []);
        }

        for (const dep of deps) {
            if (!inDegree.has(dep)) {
                inDegree.set(dep, 0);
            }
            if (!dependents.has(dep)) {
                dependents.set(dep, []);
            }
        }
    }

    for (const [node, deps] of graph) {
        inDegree.set(node, deps.length);
        for (const dep of deps) {
            dependents.get(dep)!.push(node);
        }
    }

    const queue: string[] = [];
    for (const [node, degree] of inDegree) {
        if (degree === 0) {
            queue.push(node);
        }
    }
    queue.sort();

    const result: string[] = [];

    while (queue.length > 0) {
        queue.sort();
        const node = queue.shift()!;
        result.push(node);

        for (const dependent of dependents.get(node) || []) {
            const newDegree = inDegree.get(dependent)! - 1;
            inDegree.set(dependent, newDegree);
            if (newDegree === 0) {
                queue.push(dependent);
            }
        }
    }

    if (result.length !== inDegree.size) {
        const remaining = [...inDegree.entries()]
            .filter(([_, degree]) => degree > 0)
            .map(([node]) => node);
        throw new Error(
            `Circular dependency detected involving: ${remaining.join(", ")}`,
        );
    }

    return result;
}

/**
 * Create a mapping from crate name to CDM package name.
 */
export function createCrateToPackageMap(
    contracts: ContractInfo[],
): Map<string, string> {
    const map = new Map<string, string>();
    for (const contract of contracts) {
        if (contract.cdmPackage) {
            map.set(contract.name, contract.cdmPackage);
        }
    }
    return map;
}

/**
 * Detect contracts and determine deployment order based on dependencies.
 * Uses cargo metadata for reliable workspace and dependency resolution.
 */
export function detectDeploymentOrder(rootDir: string): DeploymentOrder {
    const contracts = detectContracts(rootDir);
    const graph = buildDependencyGraph(contracts);
    const sortedCrates = toposort(graph);

    const crateToPackage = createCrateToPackageMap(contracts);
    const sortedPackages = sortedCrates.map(
        (crate) => crateToPackage.get(crate) || null,
    );

    const crateToContract = new Map(contracts.map((c) => [c.name, c]));
    const sortedContracts = sortedCrates.map(
        (crate) => crateToContract.get(crate)!,
    );

    return {
        crateNames: sortedCrates,
        cdmPackages: sortedPackages,
        contracts: sortedContracts,
    };
}
