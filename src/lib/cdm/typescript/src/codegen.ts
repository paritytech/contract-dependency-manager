import type { AbiEntry, AbiParam } from "./types";

function mapSolidityType(param: AbiParam): string {
    const t = param.type;

    // Array types
    if (t.endsWith("[]")) {
        const inner = { ...param, type: t.slice(0, -2) };
        return `${mapSolidityType(inner)}[]`;
    }

    // Fixed-size arrays like uint256[3]
    const fixedArrayMatch = t.match(/^(.+)\[(\d+)\]$/);
    if (fixedArrayMatch) {
        const inner = { ...param, type: fixedArrayMatch[1] };
        return `${mapSolidityType(inner)}[]`;
    }

    // Tuple
    if (t === "tuple" && param.components) {
        const fields = param.components.map((c) => `${c.name}: ${mapSolidityType(c)}`);
        return `{ ${fields.join("; ")} }`;
    }

    // Unsigned integers
    if (/^uint(8|16|32)$/.test(t)) return "number";
    if (/^uint\d*$/.test(t)) return "bigint"; // uint64, uint128, uint256, uint (=uint256)

    // Signed integers
    if (/^int(8|16|32)$/.test(t)) return "number";
    if (/^int\d*$/.test(t)) return "bigint";

    // Address
    if (t === "address") return "HexString";

    // Bytes
    if (t === "bytes") return "Binary";
    const bytesMatch = t.match(/^bytes(\d+)$/);
    if (bytesMatch) return `FixedSizeBinary<${bytesMatch[1]}>`;

    // Boolean
    if (t === "bool") return "boolean";

    // String
    if (t === "string") return "string";

    // Fallback
    return "unknown";
}

function generateMethodResponseType(outputs: AbiParam[] | undefined): string {
    if (!outputs || outputs.length === 0) return "undefined";
    if (outputs.length === 1) return mapSolidityType(outputs[0]);
    // Multiple outputs -> tuple-like object
    const fields = outputs.map((o, i) => {
        const name = o.name || `_${i}`;
        return `${name}: ${mapSolidityType(o)}`;
    });
    return `{ ${fields.join("; ")} }`;
}

function generateMethodArgsType(inputs: AbiParam[]): string {
    if (inputs.length === 0) return "[]";
    const parts = inputs.map((p) => `${p.name}: ${mapSolidityType(p)}`);
    return `[${parts.join(", ")}]`;
}

export function generateContractTypes(contracts: { library: string; abi: AbiEntry[] }[]): string {
    const lines: string[] = [
        "// Auto-generated by cdm install -- do not edit",
        'import type { HexString, Binary, FixedSizeBinary } from "polkadot-api";',
        "",
        'declare module "@dotdm/cdm" {',
        "    interface CdmContracts {",
    ];

    for (const contract of contracts) {
        const methods = contract.abi.filter((e) => e.type === "function" && e.name);
        lines.push(`        "${contract.library}": {`);
        lines.push("            methods: {");
        for (const method of methods) {
            const args = generateMethodArgsType(method.inputs);
            const response = generateMethodResponseType(method.outputs);
            lines.push(
                `                ${method.name!}: { args: ${args}; response: ${response} };`,
            );
        }
        lines.push("            };");
        lines.push("        };");
    }

    lines.push("    }");
    lines.push("}");
    lines.push("");

    return lines.join("\n");
}
